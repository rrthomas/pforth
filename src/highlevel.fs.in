\ pForth high level words
\
\ (c) Reuben Thomas 1991-2020
\
\ The package is distributed under the GNU GPL version 3, or, at your
\ option, any later version.
\
\ THIS PROGRAM IS PROVIDED AS IS, WITH NO WARRANTY. USE IS AT THE USERâ€™S
\ RISK.

CR .( @PACKAGE_NAME@ high level words )


\ Placeholder

: NOTHING ;


\ System variables

0 VALUE 'FORTH   \ set in per-platform INITIALIZE
0 VALUE LIMIT


\ Arithmetic #1

PROVIDE: TRUE   -1 ; [THEN]
PROVIDE: FALSE   0 ; [THEN]

PROVIDE: -   NEGATE + ; [THEN]

PROVIDE: 1+   1 + ; [THEN]
PROVIDE: 1-   1 - ; [THEN]
PROVIDE: -CELL   CELL NEGATE ; [THEN]
PROVIDE: CELL+   CELL + ; [THEN]
PROVIDE: CELL-   CELL - ; [THEN]


\ Stack manipulation #1

PROVIDE: DUP   0 PICK ; [THEN]
PROVIDE: OVER   1 PICK ; [THEN]
PROVIDE: ?DUP   DUP IF  DUP  THEN ; [THEN]
PROVIDE: ROLL
   DUP 1 + PICK  >R  DUP >R
   BEGIN  ?DUP WHILE
      SWAP  R> SWAP  >R >R
      1 -
   REPEAT
   DROP
   R> BEGIN  ?DUP WHILE
      R> SWAP
      1 -
   REPEAT
   R> ; [THEN]
PROVIDE: SWAP   1 ROLL ; [THEN]
PROVIDE: ROT   2 ROLL ; [THEN]
PROVIDE: -ROT   ROT ROT ; [THEN]
PROVIDE: TUCK   SWAP OVER ; [THEN]
PROVIDE: NIP   SWAP DROP ; [THEN]


\ Exceptions #1

[PROVIDED] THROW  INVERT [IF]
   VARIABLE 'THROW
   : 'THROW!   'THROW ! ;
   : THROW   'THROW @EXECUTE ;
[THEN]
VARIABLE 'THROWN
: (ABORT")   SWAP IF  'THROWN !  -2 THROW  ELSE DROP  THEN ;
: UNDEFINED   ( c-addr -- )   'THROWN !  -13 THROW ;
PROVIDE: BYE   0 HALT ; [THEN]


\ Arithmetic #2

PROVIDE: >-<   SWAP - ; [THEN]

PROVIDE: <   SWAP > ; [THEN]
PROVIDE: >   SWAP < ; [THEN]
PROVIDE: U<   SWAP U> ; [THEN]
PROVIDE: U>   SWAP U< ; [THEN]

PROVIDE: ARSHIFT   OVER OVER  RSHIFT -ROT
   NEGATE [ S" ADDRESS-UNIT-BITS" ENVIRONMENT? DROP  CELLS ] LITERAL +
   SWAP 0 <  SWAP LSHIFT  OR ; [THEN]

PROVIDE: <>   = INVERT ; [THEN]
PROVIDE: 0<   0 < ; [THEN]
PROVIDE: 0>   0 > ; [THEN]
PROVIDE: 0=   0 = ; [THEN]
PROVIDE: 0<>   0 <> ; [THEN]

PROVIDE: ABS   DUP 0< IF  NEGATE  THEN ; [THEN]

\ Allow division primitives without 0 divisor checking
\ Assume that if S/REM is provided, so is U/MOD
[PROVIDED] S/REM  INVERT [IF]
   : CHECK-DIVISOR DUP 0= IF -10 THROW THEN ;
   : S/REM CHECK-DIVISOR (S/REM) ;
   : U/MOD CHECK-DIVISOR (U/MOD) ;
   [PROVIDED] (/MOD) [IF]
      : /MOD CHECK-DIVISOR (/MOD) ;
   [THEN]
[THEN]

PROVIDE: /MOD   ( n1 n2 -- n3 n4 )
   DUP >R
   OVER OVER XOR -ROT
   S/REM SWAP DUP  3 PICK
   0< OVER  0<> AND  IF
      R@ ABS  SWAP ABS  -
      R> 0> IF  1  ELSE -1  THEN *
   ELSE
      R> DROP
   THEN
   >R
   0<> ROT  0< AND  +
   R> SWAP ; [THEN]
PROVIDE: /   /MOD NIP ; [THEN]
PROVIDE: MOD   /MOD DROP ; [THEN]

PROVIDE: 2*   1 LSHIFT ; [THEN]
PROVIDE: 2/   1 ARSHIFT ; [THEN]
PROVIDE: CELLS   CELL * ; [THEN]
PROVIDE: CELL/   CELL / ; [THEN]


INCLUDE" control1.fs"


\ Stack manipulation #2

PROVIDE: 2DUP   OVER OVER ; [THEN]
PROVIDE: 2DROP   DROP DROP ; [THEN]
PROVIDE: 2SWAP   3 ROLL  3 ROLL ; [THEN]
PROVIDE: 2OVER   3 PICK  3 PICK ; [THEN]
PROVIDE: 2ROT   5 ROLL  5 ROLL ; [THEN]

PROVIDE: 2>R   R> -ROT  SWAP >R >R  >R ; COMPILING [THEN]
PROVIDE: 2R>   R>  R> R> SWAP  ROT >R ; COMPILING [THEN]
PROVIDE: 2R@   R>  R> R>  2DUP >R >R  SWAP  ROT >R ; COMPILING [THEN]

: STACK-DIRECTION   SP@ SP@ - 0<  NEGATE 2* 1- ;
: DEPTH   SP@ S0 -  CELL/  STACK-DIRECTION * ;


\ Memory #1

PROVIDE: +!   TUCK @  +  SWAP ! ; [THEN]


\ Characters

\ FIXME: Add SYNONYM
: +CHAR   1 ;
: -CHAR   -1 ;
: CHAR+   1+ ;
: CHAR-   1- ;
: CHARS ; IMMEDIATE
: CHAR/ ; IMMEDIATE


\ Arithmetic #4

PROVIDE: MIN   2DUP > IF  SWAP  THEN  DROP ; [THEN]
PROVIDE: MAX   2DUP < IF  SWAP  THEN  DROP ; [THEN]

: S>D   DUP 0< ;
: D>S   DROP ;

: U>UD   0 ;
: UD>U   DROP ;

: WITHIN   OVER -  >R -  R> U< ;

: M*   * S>D ;
: UM*   * U>UD ;
: FM/MOD   NIP /MOD ;
: SM/REM   NIP S/REM ;
: UM/MOD   NIP U/MOD ;
: */   >R * R> / ;
: */MOD   >R * R> /MOD ;

: D0=   0= SWAP 0= AND ;
: D+   D>S >R D>S R>  +  S>D ;
: DNEGATE   D>S NEGATE S>D ;
: D-   DNEGATE D+ ;
: M+   S>D D+ ;
: D*   D>S >R D>S R>  *  S>D ;
: UD/MOD  UD>U >R UD>U R>  U/MOD  >R U>UD R> U>UD ;
: DABS   IF  NEGATE  THEN  U>UD ;


\ Strings #1

: COUNT   DUP CHAR+ SWAP C@ ;
: /STRING   ( c-addr1 u1 n -- c-addr2 u2 )   TUCK -  -ROT CHARS +  SWAP ;
: CMOVE   CHARS OVER + SWAP ?DO  DUP C@ I C! CHAR+  +CHAR +LOOP  DROP ;
: CMOVE>   ?DUP IF  CHARS CHAR- TUCK  + -ROT  OVER +  DO  I C@ OVER C!  CHAR-
   -CHAR +LOOP  ELSE DROP  THEN  DROP ;
: MOVE   -ROT 2DUP > IF  ROT CMOVE  ELSE ROT CMOVE>  THEN ;
: FILL   -ROT  CHARS OVER + SWAP ?DO  DUP I C!  +CHAR +LOOP  DROP ;
: ERASE   0 FILL ;


\ Compiler #1

0 VALUE DP
: ALLOT   DP +! ;
: HERE   DP @ ;

VARIABLE ROOTDP

: ALIGNED   CELL+ 1-  -CELL AND ;
: ALIGN   HERE ALIGNED  DP ! ;
: ,   HERE  CELL ALLOT  ! ;
: C,   HERE  +CHAR ALLOT  C! ;
: CALIGN   HERE  DUP ALIGNED  >-< 0 ?DO  DUP C,  LOOP  DROP ;

: ADDRESS!   ! ;
: >REL   ( from to -- offset )   DUP IF  >-<  ELSE NIP  THEN ;
: REL,   HERE SWAP >REL , ;
: REL@   DUP @  ?DUP IF  +  ELSE DROP 0  THEN ;
: REL!   ( to 'link -- )   DUP  ROT >REL  SWAP ! ;

VARIABLE STATE
: [   0 STATE ! ; IMMEDIATE COMPILING
: ]   1 STATE ! ;

VARIABLE #ORDER
CREATE CONTEXT  8 CELLS ALLOT \ FIXME: constant

VARIABLE CURRENT
: GET-CURRENT   CURRENT @ ;
: SET-CURRENT   CURRENT ! ;
: LAST   GET-CURRENT  REL@ ;

: >LINK   3 CELLS - ;
: >COMPILE   2 CELLS - ;
: >INFO   CELL- ;
: >NAME   DUP >INFO 3 + C@  31 AND 1+ CHARS ALIGNED  SWAP >LINK  >-< ;

: IMMEDIATE   LAST >INFO  DUP @  $80000000 OR  SWAP !
   LAST DUP >COMPILE REL! ;
: COMPILING   LAST >INFO  DUP @  $40000000 OR  SWAP ! ;
: SMUDGE!   ( f a-addr -- )   >INFO  TUCK @  $20000000 DUP INVERT  ROT AND
   -ROT AND  OR  SWAP ! ;
: SMUDGE   ( f -- )   LAST  SMUDGE! ;


\ Interpreter #1

VARIABLE 'BUFFERS
: PAD   'BUFFERS @ 256 + ;
: TOKEN   'BUFFERS @ 512 + ;
: S"B   'BUFFERS @ 768 + ;
: SCRATCH   'BUFFERS @ 1024 + ;


INCLUDE" os-compiler.fs"   \ words necessary for the machine
: CODE-MOVE   CELLS OVER + SWAP ?DO  DUP @  I CODE!  CELL+
   CELL +LOOP  DROP ;
INCLUDE" compiler.fs"
DEFER CURRENT-COMPILE,  ' COMPILE, IS CURRENT-COMPILE,
INCLUDE" call-cells.fs" CONSTANT #CALL-CELLS
: (POSTPONE)   CURRENT-COMPILE, ;
INCLUDE" compiler1.fs"
INCLUDE" compiler-postpone.fs"
INCLUDE" defer-fetch-store.fs"


\ Strings #2

\ Copy string c-addr1 u1 into buffer c-addr2 u2, and NUL-terminate it
: C0END   ( c-addr1 u1 c-addr2 u2 -- )   1- ROT MIN  2DUP + >R
   MOVE  0 R> C! ;
\ FIXME: caller should allocate buffer!
: SCRATCH-C0END   ( c-addr1 u1 -- HERE )   SCRATCH 256 C0END  SCRATCH ;
: ",   ( c-addr u -- )   DUP C,  HERE SWAP  DUP ALLOT  CMOVE ;

INCLUDE" strings2a.fs"


INCLUDE" fileio.fs"
INCLUDE" terminal.fs"   \ terminal I/O words


\ Interpreter #2

: ABORT   -1 THROW ;
: QUIT   -56 THROW ;


INCLUDE" control2.fs"
INCLUDE" strings2b.fs"


\ Memory #2

: 2@   DUP CELL+ @  SWAP @ ;
: 2!   TUCK !  CELL+ ! ;
: 2,   , , ;


\ Strings #3

: BLANK   BL FILL ;

: COMPARE   ( c-addr1 u1 c-addr2 u2 -- n )
   ROT 2SWAP 2OVER MIN               \ no. of characters to check
   DUP 0> IF                         \ if strings not both length 0
      0 DO                           \ for each character
         OVER C@  OVER C@            \ get the characters
         <> IF                       \ if they're unequal
            C@ SWAP  C@              \ retrieve the characters
            < 2* INVERT              \ construct the return code
            NIP NIP UNLOOP EXIT      \ and exit
         THEN
         CHAR+ SWAP  CHAR+ SWAP      \ increment addresses
      LOOP
      2DROP                          \ get rid of addresses
      2DUP <> -ROT < 2* INVERT AND   \ construct return code
   ELSE                              \ if strings are both length 0
      2DROP 2DROP                    \ leave 0
   THEN ;

: SEARCH   ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 f )
   ROT 2DUP                          \ copy lengths
   OVER SWAP U>  SWAP 0=  OR IF      \ if u2>u1 or u2=0
      NIP NIP  FALSE EXIT            \ exit with false flag
   THEN
   -ROT 2OVER                        \ save c-addr1 u1
   2SWAP TUCK 2>R                    \ save c-addr2 u2
   - 1+ OVER +  SWAP                 \ make c-addr1 c-addr1+u1-u2
   2R> 2SWAP                         \ retrieve c-addr2 u2
   DO
      2DUP I OVER COMPARE 0= IF      \ if we find the string
         2DROP +  I TUCK -           \ calculate c-addr3 u3
         TRUE UNLOOP EXIT            \ exit with true flag
      THEN
   LOOP
   2DROP FALSE ;                     \ leave c-addr1 u1 false


INCLUDE" control3.fs"


\ Mass storage input/output #1

: READ-LINE   ( c-addr u1 fid -- u2 flag ior )
   >R  OVER SWAP                     \ save fid and copy c-addr
   R@ READ-FILE                      \ fill buffer
   ?DUP IF                           \ if an error occurred
      NIP NIP 0 FALSE ROT            \ leave 0 false ior
      R> DROP  EXIT                  \ drop fid and exit
   THEN
   DUP 0= IF                         \ if the line is of length 0,
      NIP FALSE 0  R> DROP  EXIT     \ exit with false flag
   THEN
   TUCK                              \ save no. of chars read
   EOL SEARCH  ROT DROP              \ search for EOL; drop address
   IF                                \ if found,
      TUCK -  SWAP                   \ calculate length, save it
      EOL NIP - ?DUP IF              \ if not at the end of the line,
         R@ FILE-POSITION            \ get the current file position
         ?DUP IF                     \ if an error occurred
            >R 2DROP DROP  FALSE R>  \ clear up, leave false flag
            R> DROP  EXIT            \ and ior, and exit
         THEN
         ROT U>UD D-                 \ set pointer to just after EOL
         R@ REPOSITION-FILE
         ?DUP IF                     \ if there was an error
            FALSE SWAP  EXIT         \ exit with error code
         THEN
      THEN
   ELSE
      DROP                           \ else u2=u1
   THEN
   R> DROP                           \ drop fid
   TRUE 0 ;                          \ leave true flag, ior=0
: WRITE-LINE   ( c-addr u fid -- ior )
   >R                                \ save fid
   R@ WRITE-FILE                     \ write the line
   ?DUP IF                           \ if there was an error
      R> DROP  EXIT                  \ drop fid and exit
   THEN
   EOL R> WRITE-FILE ;               \ write the line terminator;
                                     \ ior is WRITE-FILE's result


\ Terminal input/output #1

: SPACE   BL EMIT ;
: SPACES   0 ?DO  SPACE  LOOP ;
: TYPE   CHARS OVER + SWAP ?DO  I C@ EMIT  +CHAR +LOOP ;
: -TRAILING   BEGIN  DUP IF  2DUP 1- CHARS + C@  BL =  ELSE FALSE  THEN
   WHILE  1-  REPEAT ;


\ Mass storage input/output #2

0 VALUE "BLOCK
VARIABLE SCR
64 DUP CONSTANT /LINE
16 DUP CONSTANT LINES/BLOCK
* DUP CONSTANT /BLOCK   \ save value for later
: OPEN-BLOCKS   ( fam -- fid )   "BLOCK ?DUP IF  COUNT ROT OPEN-FILE
   ABORT" blocks file can't be opened"  ELSE TRUE ABORT" no blocks file"  THEN ;
: @BLOCK   ( c-addr u -- )   R/O OPEN-BLOCKS  >R  1- 10 LSHIFT U>UD
   R@ REPOSITION-FILE DROP  /BLOCK R@ READ-FILE 2DROP  R> CLOSE-FILE DROP ;
: !BLOCK   ( c-addr u -- )   W/O OPEN-BLOCKS  >R  1- 10 LSHIFT U>UD
   R@ REPOSITION-FILE DROP  /BLOCK R@ WRITE-FILE DROP  R> CLOSE-FILE DROP ;

CELL+ CONSTANT /BLOCK-BUFFER   \ uses value saved above
: 'BUFFER   'BUFFERS @  1280 + ;   \ address of block buffer
: >BLOCK   CELL+ ;

: UPDATE   'BUFFER  DUP @ $80000000 OR  SWAP ! ;
: UPDATED?   ( -- f )   'BUFFER @  0< ;
: (BUFFER)   ( u -- c-addr f )
   'BUFFER                           \ address of block buffer
   TUCK @ $7FFFFFFF AND  OVER = IF   \ if the current block was requested,
      DROP >BLOCK  TRUE EXIT         \ leave address and true flag, and exit
   THEN
   UPDATED? IF                       \ was the last block updated?
      OVER >BLOCK OVER !BLOCK        \ if so, save it
   THEN
   OVER !                            \ set new block no., & clear update flag
   >BLOCK  FALSE ;                   \ leave address and false flag
: BUFFER   ?DUP IF  (BUFFER) DROP  THEN ;
: BLOCK   ?DUP IF  DUP (BUFFER) IF  NIP  ELSE DUP ROT @BLOCK  THEN  THEN ;

1024 CONSTANT /FILE-BUFFER
16 CONSTANT #FILE-BUFFERS
VARIABLE FILE-BUFFER#  0 ' FILE-BUFFER# >BODY !   \ next file buffer to use
0 VALUE FIRST-FILE
: ALLOCATE-BUFFER   ( -- c-addr ior )   FILE-BUFFER# @  DUP #FILE-BUFFERS
   = IF  -1  ELSE DUP 1+ FILE-BUFFER# !  /FILE-BUFFER *  FIRST-FILE +  0
   THEN ;
: FREE-BUFFER   ( -- ior )   FILE-BUFFER#  DUP @ 0= IF  DROP -1
   ELSE -1 SWAP +!  0  THEN ;


\ Terminal input/output #2

INCLUDE" accept.fs"

VARIABLE >IN

VARIABLE BLK

VARIABLE EVALUAND
VARIABLE #EVALUAND

VARIABLE #TIB
: TIB   'BUFFERS @ ;

VARIABLE #FIB
0 VALUE FIB

0 VALUE SOURCE-ID
: SOURCE
   BLK @ ?DUP IF
      BLOCK /BLOCK
   ELSE
      CASE SOURCE-ID
         -1 OF  EVALUAND @  #EVALUAND @  ENDOF
         0 OF  TIB  #TIB @  ENDOF
         >R  FIB  #FIB @  R>
      ENDCASE
   THEN ;

\ SAVE-INPUT returns the current input source immediately under the number of
\ items returned, encoded as:
\       0 = user input device, -1 = string
\       1 = block,              2 = file
: SAVE-INPUT   ( -- xn...x1 n )
   >IN @                             \ get >IN
   BLK @ ?DUP IF                     \ if input source is a block,
      1 3                            \ leave >IN BLK 1
   ELSE
      CASE SOURCE-ID                 \ otherwise look at SOURCE-ID
         0 OF  0 2  ENDOF            \ if 0, leave >IN 0
         -1 OF                       \ if -1, leave >IN EVALUAND
            EVALUAND @ #EVALUAND @   \ #EVALUAND -1
            -1 4
         ENDOF
         >R  FIB #FIB @ SOURCE-ID 2 5  R>
                                     \ if a file leave >IN FIB #FIB fid 2
      ENDCASE
   THEN ;
\ RESTORE-INPUT always succeeds unless the input source buffer being restored
\ has been altered, which it has no way of telling.
: RESTORE-INPUT   ( xn...x1 n -- f )
   DROP
   CASE
      0 OF  0 BLK !  0 TO SOURCE-ID  ENDOF
      1 OF  BLK !  ENDOF
      2 OF  0 BLK !  TO SOURCE-ID  #FIB !  TO FIB  ENDOF
      -1 OF
         0 BLK !   #EVALUAND ! EVALUAND !  -1 TO SOURCE-ID
      ENDOF
   ENDCASE
   >IN !
   FALSE ;

VARIABLE 'RETURN
: SAVE-INPUT>R   \ save input specification to return stack
   R> 'RETURN !                      \ save return address
   SAVE-INPUT                        \ get input specification
   DUP                               \ push it to return stack
   BEGIN  ?DUP WHILE                 \ can't use a DO loop as this would
      ROT >R                         \ interfere with the return stack
      1-
   REPEAT
   >R
   'RETURN @ >R ;                    \ restore return address
: R>RESTORE-INPUT   \ restore input specification from return stack
   R> 'RETURN !                      \ save return address
   R> DUP                            \ pop input specification
   BEGIN  ?DUP WHILE                 \ from return stack
      R> -ROT                        \ can't use a DO loop as this would
      1-                             \ interfere with the return stack
   REPEAT
   RESTORE-INPUT DROP                \ set input specification
   'RETURN @ >R ;                    \ restore return address

DEFER SCAN-TEST
: SCAN   ( char xt -- c-addr u )
   IS SCAN-TEST
   SOURCE CHARS                      \ get input source
   OVER +                            \ end of input buffer + 1
   SWAP >IN @ CHARS +                \ start of parse area
   SWAP ROT  OVER 3 PICK ?DO         \ save start & end of input buffer
      DUP I C@ SCAN-TEST IF          \ if test true,
         NIP  I SWAP  LEAVE          \ drop end, leave I and exit
      THEN
   +CHAR +LOOP                       \ if end of loop reached, end left
   DROP                              \ get rid of delimiter
   OVER -  DUP >IN +!                \ advance >IN
   CHAR/ ;                           \ leave count and length

: PARSE   ( char -- c-addr u )
   ['] = SCAN                        \ search for delimiter
   >IN DUP @ CHAR+                   \ advance >IN past delimiter
   SOURCE NIP  MIN SWAP ! ;          \ making sure it stays in the source

: WORD   ( char -- c-addr )
   DUP                               \ copy delimiter
   ['] <> SCAN  2DROP                \ skip delimiter
   PARSE                             \ get the delimited string
   TOKEN  2DUP C!                    \ store count
   CHAR+  2DUP +  BL SWAP C!         \ store blank at end of string
   SWAP CMOVE                        \ store string
   TOKEN ;                           \ leave the string's address

: .(   [CHAR] ) PARSE TYPE ; IMMEDIATE

\ Set default PROGRAM-NAME in case for some reason there is no ARG 0
HERE  S" @PACKAGE@" ",  VARIABLE "PROGRAM-NAME  ' "PROGRAM-NAME >BODY REL!

: ERROR-PREFIX   "PROGRAM-NAME REL@ COUNT TYPE  S" : " TYPE ;


INCLUDE" compiler2.fs"
INCLUDE" interpreter3.fs"


\ Numeric conversion

VARIABLE BASE
VARIABLE HELD

: DECIMAL   10 BASE ! ;
: HEX   16 BASE ! ;
: HOLD   -CHAR HELD +!  HELD @ C! ;
: SIGN   0< IF  [CHAR] - HOLD  THEN ;
: <#   TOKEN HELD ! ;
: #>   2DROP  HELD @  TOKEN OVER - ;
: #   BASE @ U>UD UD/MOD  2SWAP UD>U  DUP 10 < IF  [CHAR] 0 +
   ELSE [ CHAR A 10 - ] LITERAL +  THEN  HOLD ;
: #S   BEGIN  #  2DUP D0= UNTIL ;

: D.R   -ROT  TUCK DABS  <# #S ROT SIGN #>  ROT OVER -  0 MAX SPACES  TYPE ;
: D.   0 D.R  SPACE ;
: .R   SWAP S>D  ROT D.R ;
: .   0 .R  SPACE ;
: DEC.   BASE @ SWAP  DECIMAL .  BASE ! ;
: U.R   SWAP U>UD  ROT D.R ;
: U.   0 U.R  SPACE ;
: H.   BASE @  SWAP HEX U.  BASE ! ;

: >NUMBER   ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
   DUP IF                            \ if something to convert
      CHARS OVER + SWAP              \ form limits for a loop
      TUCK  OVER >R                  \ save initial address and
                                     \ address of last character + 1
      DO
         C@                          \ get next character
         DUP [CHAR] A < IF           \ convert to a digit
            [CHAR] 0 -  ELSE [ CHAR A 10 - ] LITERAL -
         THEN
         DUP  BASE @ - 0< INVERT     \ if digit is too large...
         OVER 0<  OR IF              \ or too small
            DROP I  LEAVE            \ leave address of character
         THEN                        \ and exit the loop
         >R BASE @ U>UD D*           \ multiply n by BASE
         R> M+                       \ add new digit
         I CHAR+                     \ address of next character
      LOOP
      DUP R> >-<                     \ construct u'
   THEN ;
: SKIP-CHAR   ( c-addr u -- c-addr+1 u-1)   1- SWAP  CHAR+ SWAP ;
: NUMBER   ( c-addr -- d true | n false )
   DUP >R                            \ save address of string
   0. ROT                            \ make accumulator for >NUMBER
   COUNT                             \ count the string
   BASE @ >R                         \ save BASE
   CASE  OVER C@                     \ set base if leading #, $ or %
      [CHAR] # OF  10 BASE !  SKIP-CHAR  ENDOF
      [CHAR] $ OF  16 BASE !  SKIP-CHAR  ENDOF
      [CHAR] % OF   2 BASE !  SKIP-CHAR  ENDOF
   ENDCASE
   OVER C@                           \ get the leading character
   [CHAR] - =  DUP >R  IF            \ skip first character if it's
      SKIP-CHAR                      \ a minus and save the flag
   THEN
   FALSE >R                          \ save false flag
   BEGIN
      >NUMBER                        \ convert up to non-digit
      ?DUP WHILE                     \ if the string's not finished,
      OVER C@ 4 / 11 <> IF           \ is the non-digit punctuation?
         2R> 2DROP                   \ FIXME: Tighten up parsing
         R> BASE !  R> UNDEFINED     \ if not, then not a number
      THEN
      R> DROP  TRUE >R               \ if so, set double no. flag
      SKIP-CHAR                      \ and skip the punctuation
   REPEAT
   DROP                              \ drop string address
   2R> >R                            \ retrieve leading minus flag
   IF  DNEGATE  THEN                 \ if leading minus, negate no.
   R@ INVERT IF  D>S  THEN           \ return single or double no.
   R>                                \ and flag as appropriate
   R> BASE !                         \ restore BASE
   R> DROP ;                         \ drop address of string


\ Mass storage input/output #3

: LIST   ( u -- )
   BASE @ SWAP  DECIMAL              \ save BASE and switch to decimal
   DUP SCR !                         \ set SCR to block displayed
   CR  ." Block " DUP .              \ print heading
   BLOCK                             \ fetch block
   LINES/BLOCK 0 DO                  \ for each line
      CR SPACE  I 2 .R  SPACE        \ print line number
      DUP /LINE TYPE                 \ print text
      /LINE +                        \ advance pointer to block
   LOOP
   CR                                \ put CR at end of last line
   DROP                              \ get rid of pointer
   BASE ! ;                          \ restore BASE


\ Compiler #3

: DEFINITIONS   CONTEXT @  SET-CURRENT ;

: GET-ORDER   #ORDER @  DUP IF  DUP >R  CELLS  CONTEXT TUCK + CELL-  DO
   I @  -CELL +LOOP  R>  THEN ;

DEFER VISIBLE?   \ word visibility test
: ALL-VISIBLE   ( wid xt n -- true )   2DROP DROP  TRUE ;
\ VISIBLE? must be set before VET-WORDLIST is called, with a word whose
\ stack effect is ( wid xt n -- f ), where wid is the word list and xt the
\ execution token of the found word and n its immediacy flag, and f is true
\ if the word is deemed visible by the test.
: VET-WORDLIST   ( c-addr u wid -- 0 | xt 1 | xt -1 )
   DUP >R                            \ save wid
   BEGIN  REL@ ?DUP WHILE            \ for all words in list
      DUP >NAME                      \ get name field address
      2OVER ROT COUNT                \ COUNT the strings
      COMPARE 0= IF                  \ if the name matches
         DUP >INFO @                 \ and the word is not SMUDGEd
         $20000000 AND 0= IF
            R@ OVER                  \ get wid and xt of word
            DUP >INFO @ 0< 2* INVERT \ get immediacy flag
            DUP >R                   \ save flag
            VISIBLE? IF              \ if word is deemed visible
               NIP NIP  R>  R> DROP  \ get flag, drop string and wid,
               EXIT                  \ and exit
            ELSE
               R> DROP               \ else drop immediacy flag
            THEN
         THEN
      THEN
      >LINK                          \ leave next link field
   REPEAT
   2DROP  R> DROP                    \ get rid of c-addr, u and wid,
   0 ;                               \ and set flag to 0
: SEARCH-WORDLIST   ( c-addr u wid -- 0 | xt 1 | xt -1 )
   ['] ALL-VISIBLE IS VISIBLE?  VET-WORDLIST ;

: SELECT   ( a-addr1 xt -- a-addr2 n )
   IS VISIBLE?                       \ set up visibility selector
   >R  GET-ORDER  R> SWAP            \ get search order
   ?DUP IF                           \ if search order non-empty
      1 SWAP DO                      \ for each word list in order
         TUCK COUNT ROT VET-WORDLIST \ search it
         ?DUP IF                     \ if the word is found
            I -ROT  2>R              \ save xt and immediacy flag
            0 DO  DROP  LOOP         \ drop wids and string address
            2R> UNLOOP EXIT          \ retrieve results and exit
         THEN
      -1 +LOOP
   THEN
   0 ;                               \ if not found leave string & 0 flag
: FIND   ( c-addr -- a-addr n )   ['] ALL-VISIBLE SELECT ;

DEFER CURRENT-LITERAL  ' LITERAL IS CURRENT-LITERAL
DEFER CURRENT-RELATIVE-LITERAL  ' RELATIVE-LITERAL IS CURRENT-RELATIVE-LITERAL
: POSTPONE   BL WORD FIND  ?DUP 0= IF  UNDEFINED  THEN  0> IF  >COMPILE REL@
   CURRENT-COMPILE,  ELSE  CURRENT-LITERAL  ['] (POSTPONE) CURRENT-COMPILE,  THEN ;
IMMEDIATE COMPILING

( A header has the following structure:

  Name field                         counted string, up to 8 cells
  Link field                         1 cell, relative link to LAST
  Compilation method                 1 cell, relative pointer
  Info field                         1 cell: bit 31 is IMMEDIATE flag,
                                     bit 30 is COMPILING flag,
                                     bit 29 is SMUDGE flag,
                                     rest of MS byte is length of name field,
                                     byte 2 is reserved for the back-end
                                     bytes 0 & 1 are offset to DOES> code for a
                                     defining word
)
: HEADER   ( c-addr -- )
   ALIGN                             \ align DP for new definition
   DUP C@ 31 MIN                     \ get name (max. 31 chars)
   2DUP SWAP C!
   OVER COUNT
   GET-CURRENT SEARCH-WORDLIST IF    \ check name is unique
      DROP OVER COUNT TYPE ."  is not unique "
   THEN
   DUP >R                            \ save length
   CHAR+                             \ length of name field
   HERE SWAP                         \ beginning of name field
   DUP ALLOT                         \ reserve space for name field
   CMOVE                             \ write name in name field
   BL CALIGN                         \ pad with spaces to next cell boundary
   LAST REL,                         \ store link to last word
   0 ,                               \ store null compilation method
   R> 24 LSHIFT  ,                   \ save length of name field
   HERE GET-CURRENT REL! ;           \ update CURRENT word list


\ Exceptions #2

VARIABLE HANDLER  0 ' HANDLER >BODY !
: CATCH
   SP@ -CELL STACK-DIRECTION * +  >R \ push data stack pointer
   HANDLER @ >R                      \ push pointer to last frame
   SAVE-INPUT>R                      \ push current input source
   RP@ HANDLER !                     \ set pointer to current frame
   EXECUTE                           \ execute guarded word
   R> BEGIN  ?DUP WHILE              \ pop input source;
     R> DROP  1-                     \ can't use a DO loop as that would
   REPEAT                            \ interfere with the return stack
   R> HANDLER !                      \ reset pointer to previous frame
   R> DROP                           \ discard saved stack pointer
   0 ;                               \ leave OK flag


\ Interpreter #4

: FOREIGN?   ( wid -- f )   2 CELLS + @  1023 > ;
: LOCAL?   ( wid xt n -- f )
   NIP  1 <> IF                      \ is the word non-immediate?
      STATE @                        \ if so, if we are compiling,
      GET-CURRENT FOREIGN?  AND IF   \ and CURRENT is foreign,
         GET-CURRENT =               \ word must be in CURRENT to be compiled
         EXIT
      THEN
   THEN
   FOREIGN? INVERT ;                 \ otherwise word must be native
: NON-META?   ( wid xt n -- f )
   NIP  1 <>  STATE @  AND IF        \ if we are compiling a word,
      DROP  TRUE                     \ allow any word;
   ELSE
      FOREIGN? INVERT                \ to execute, word must be native
   THEN ;
VARIABLE 'SELECTOR  ' LOCAL?  ' 'SELECTOR >BODY REL!
: INTERPRET
   BEGIN  BL WORD  DUP C@ WHILE      \ while text in input stream
      'SELECTOR REL@ SELECT          \ search for word
      DUP IF                         \ if word found in dictionary
         STATE @ 0= IF               \ if interpreting, execute it
            DROP                     \ drop found flag
            DUP >INFO @ $40000000 AND
            IF  -14 THROW  THEN
            EXECUTE
         ELSE
            0> IF                    \ if immediate, execute compile method
               >COMPILE REL@ EXECUTE
            ELSE
               CURRENT-COMPILE,      \ if non-immediate, compile it
            THEN
         THEN
      ELSE                           \ if word is not found
         DROP                        \ drop found flag
         NUMBER                      \ try getting a number
         STATE @ IF                  \ compile if STATE is non-zero
            IF                       \ if a double number
               SWAP                  \ compile MS word
               CURRENT-LITERAL
            THEN
            CURRENT-LITERAL          \ compile single no./LS word
         ELSE
            DROP                     \ else get rid of flag
         THEN
      THEN
   REPEAT DROP ;                     \ get rid of input address

: EVALUATE   SAVE-INPUT>R  -1 TO SOURCE-ID  #EVALUAND !  EVALUAND !  0 >IN !
   0 BLK !  INTERPRET  R>RESTORE-INPUT ;

: REFILL   ( -- f )
   BLK @ IF                          \ if interpreting a block
      1 BLK +!  0 >IN !  TRUE        \ go on to next block
   ELSE
      CASE SOURCE-ID                 \ switch on SOURCE-ID
         0 OF                        \ if user input device
            TIB 80 ACCEPT            \ get a line of text to TIB
            #TIB !  0 >IN !  TRUE
         ENDOF
         -1 OF  FALSE  ENDOF         \ if a string, return false
         >R                          \ save switch
         FIB /FILE-BUFFER R@ READ-LINE \ else read a line from file
         ABORT" file read error during REFILL"
                                     \ if an exception occurred, abort
         SWAP #FIB !  0 >IN !        \ set no. of chars in line
         R>                          \ restore switch
      ENDCASE
   THEN ;

: ?STACK   DEPTH 0< ABORT" stack underflow" ;
: REPL
   POSTPONE [
   0 BLK !  0 TO SOURCE-ID
   BEGIN  CR REFILL WHILE
      INTERPRET  ?STACK  STATE @ 0= IF  ." ok"  THEN
   REPEAT
   TRUE ABORT" parse area empty" ;
: HANDLE-ERROR ( n -- )
   CASE
      -1 OF  ( ABORT )  ENDOF
      -2 OF  'THROWN @ COUNT TYPE  ENDOF
      -9 OF   -9 HALT  ENDOF
      -10 OF  ." division by zero"  ENDOF
      -11 OF  ." quotient too large"  ENDOF
      -13 OF  'THROWN @ COUNT TYPE  ."  ?"  ENDOF
      -14 OF  ." compilation only"  ENDOF
      -20 OF  ." write to a read-only location"  ENDOF
      -23 OF  -23 HALT  ENDOF
      -56 OF  ( QUIT )  ENDOF
      -512 OF  ." unknown option " 'THROWN @ COUNT TYPE  CR  1 HALT  ENDOF
      ." exception " DUP . ." raised"
   ENDCASE ;
: (QUIT)
   BEGIN
      R0 RP!
      ['] REPL CATCH                 \ cannot return normally
      DUP HANDLE-ERROR
      -56 <> IF  S0 SP!  THEN
   AGAIN ;


\ Tools

: [ELSE] ( -- )
   1 BEGIN                                   \ level
      BEGIN BL WORD COUNT DUP WHILE          \ level adr len
            2DUP S" [IF]" COMPARE 0= IF      \ level adr len
               2DROP 1+                      \ level'
            ELSE                             \ level adr len
               2DUP S" [ELSE]" COMPARE 0= IF \ level adr len
                  2DROP 1- DUP IF 1+ THEN    \ level'
               ELSE                          \ level adr len
                  S" [THEN]" COMPARE 0= IF   \ level
                     1-                      \ level'
                  THEN
               THEN
            THEN ?DUP 0= IF EXIT THEN        \ level'
      REPEAT 2DROP                           \ level
   REFILL 0= UNTIL                           \ level
   DROP ; IMMEDIATE
: [IF] ( flag -- )
   0= IF POSTPONE [ELSE] THEN ; IMMEDIATE
: [THEN] ( -- ) ; IMMEDIATE

: DEFINED?   FIND NIP 0<> ;
: [DEFINED]   BL WORD DEFINED? ; IMMEDIATE
: [UNDEFINED]   POSTPONE [DEFINED] INVERT ; IMMEDIATE


INCLUDE" compiler4.fs"


\ Miscellaneous

: (
   BEGIN
      [CHAR] ) PARSE 2DROP           \ parse up to ) or end of area
      SOURCE-ID 1+  2 U< IF          \ exit if not reading from file
         EXIT
      THEN
      >IN @ IF                       \ was parse area empty?
         SOURCE DROP >IN @ 1- CHARS +  C@ [CHAR] ) <>
                                     \ if not, was last character )?
      ELSE
         TRUE                        \ if empty we must refill
      THEN
      WHILE                          \ if parse area empty or no )
      REFILL 0=                      \ found, refill and parse again
   UNTIL THEN ; IMMEDIATE

: \   BLK @ IF  >IN  DUP @ CHARS  /LINE +  /LINE / /LINE *  CHAR/ SWAP !
   ELSE  SOURCE NIP >IN ! THEN ; IMMEDIATE
: ?   @ . ;
: .S   ?STACK  DEPTH ?DUP IF  1- 0 SWAP DO  I PICK .  -1 +LOOP
   ELSE ." stack empty "  THEN ;


\ Mass storage input/output #4

: FROM   ( name )   BL WORD COUNT  HERE TO "BLOCK  ", ;

: LOAD   SAVE-INPUT>R  BLK !  0 >IN !  INTERPRET  R>RESTORE-INPUT ;
: THRU   1+ SWAP DO  I LOAD  LOOP ;
: SAVE-BUFFERS
   UPDATED? IF                       \ if the buffer was updated
      'BUFFER  DUP @ $7FFFFFFF AND   \ get the block number
      OVER >BLOCK OVER !BLOCK        \ save the block
      SWAP !                         \ mark the buffer as not updated
   THEN ;
: EMPTY-BUFFERS   0 'BUFFER ! ;
: FLUSH   SAVE-BUFFERS EMPTY-BUFFERS ;

: -->   0 >IN !  1 BLK +! ;

: INCLUDE-FILE   ( i*x fid -- j*x )
   SAVE-INPUT>R                      \ save current input source
   TO SOURCE-ID  0 BLK !             \ set up new input source
   ALLOCATE-BUFFER IF                \ allocate new file buffer
      SOURCE-ID CLOSE-FILE
      TRUE ABORT" no more file buffers"
   THEN
   TO FIB
   REFILL DUP IF                     \ check for #! line at start of file
      #FIB @ 1 > IF                  \ if we have at least 2 characters
         FIB C@  [CHAR] # =
         FIB 1+ C@  [CHAR] ! =
         AND  IF                     \ and the first two are `#!'
            DROP  REFILL             \ then skip the line
         THEN
      THEN
   THEN
   BEGIN  WHILE                      \ interpret the file
      ['] INTERPRET CATCH ?DUP IF    \ close the file if an exception is
         SOURCE-ID CLOSE-FILE DROP   \ generated, then pass the exception on
         FREE-BUFFER DROP            \ having freed the buffer
         THROW
      THEN
      REFILL
   REPEAT
   FREE-BUFFER ABORT" no file buffer to free"
                                     \ free the file buffer
   R>RESTORE-INPUT ;                 \ restore the input source
: INCLUDED   ( i*x c-addr u -- j*x )
   2DUP  R/O OPEN-FILE IF            \ open file; if error,
      DROP                           \ get rid of bad fid
      \ TYPE FIXME: include file name in error message
      TRUE ABORT" file can't be INCLUDED" \ abort with error message
   THEN
   >R                                \ save fid
   2DROP                             \ drop c-addr u
   R@ INCLUDE-FILE                   \ include the file
   R> CLOSE-FILE                     \ close the file; if error,
   ABORT" error after INCLUDEing" ;  \ give error message and abort
: INCLUDE"   ( file )   [CHAR] " WORD COUNT  INCLUDED ;


INCLUDE" compiler5.fs"
INCLUDE" defining.fs"


\ Word lists

: DICTIONARY   CREATE  HERE CELL+ ,  HERE  OVER ALLOT  SWAP ERASE
   DOES>  TO DP ;
: ROOT   ROOTDP TO DP ;

VARIABLE CHAIN  0 ' CHAIN >BODY !
( A wordlist has the following structure:

  Head of list         relative link to most recently defined word
  Link field           relative link to next wordlist in CHAIN
  Info field           bit 10 is FOREIGN flag
)
: WORDLIST   ALIGN HERE  0 ,  HERE  CHAIN  DUP REL@ REL,  REL!  0 , ;
INCLUDE" vocabulary.fs"
VOCABULARY FORTH
: FORTH-WORDLIST   ['] FORTH >BODY REL@ ;
: ALSO   CONTEXT  DUP CELL+  #ORDER @ CELLS  MOVE  1 #ORDER +! ;
: ONLY   FORTH  1 #ORDER ! ;
: FOREIGN   CONTEXT @  2 CELLS +  DUP @ 1024 OR  SWAP ! ;
: NATIVE   CONTEXT @  2 CELLS +  DUP @ 1023 AND  SWAP ! ;
: SET-ORDER   DUP -1 = IF  ONLY  ELSE  DUP #ORDER !  CELLS  CONTEXT TUCK +
   SWAP ?DO  I !  CELL +LOOP  THEN ;
: PREVIOUS   GET-ORDER  DUP 0> IF  NIP 1-  THEN  SET-ORDER ;
: ORDER   ." CONTEXT: "  GET-ORDER  0 ?DO  H.  LOOP  CR ." CURRENT: "
   GET-CURRENT H. ;

: (FORGET)
   >NAME DP !
   CHAIN DUP  BEGIN  @  DUP HERE < UNTIL  OVER !
   BEGIN  @ ?DUP WHILE
      DUP CELL-  DUP @
      BEGIN  DUP HERE < INVERT WHILE  >LINK REL@  REPEAT
      SWAP REL!
   REPEAT ;
: FORGET   ( name )   ' (FORGET) ;
: MARKER   ( name )
   CREATE                            \ create the MARKER word
   GET-ORDER  DUP ,                  \ save the search order
   0 ?DO  ,  LOOP
   LAST ,                            \ and the last definition.
   DP ,                              \ and the current DP
   DOES>                             \ at runtime:
      DUP @  DUP >R                  \ save no. of lists in order
      CELLS 2DUP + CELL+             \ get old value of HERE
      DP >R                          \ save current DP
      DUP CELL+ @  TO DP             \ restore old DP
      @ (FORGET)                     \ delete words after old HERE
      R> TO DP                       \ restore current DP
      OVER CELL+ -ROT + DO           \ retrieve the search order
         I @
      -CELL +LOOP
      R>                             \ retrieve size of search order
      SET-ORDER ;                    \ restore the search order

VARIABLE CURSORX   \ cursor x position during WORDS
: ADVANCE   ( +n -- )   CURSORX +! ;
: WRAP?   ( -- f )   CURSORX @ + WIDTH < INVERT ;
: NEWLINE   0 CURSORX !  CR ;
3 CONSTANT GAP
: WORDLIST-WORDS   ( wid -- )
   NEWLINE                           \ start listing on a new line
   BEGIN  REL@ ?DUP WHILE            \ for each word in the chain
      DUP >NAME COUNT                \ get the name
      DUP WRAP? IF  NEWLINE  THEN    \ new line if necessary
      DUP ADVANCE                    \ advance the cursor
      TYPE                           \ type the name
      GAP WRAP? IF                   \ leave a gap or move to a new
         NEWLINE                     \ line
      ELSE
         GAP  DUP SPACES  ADVANCE
      THEN
      >LINK                          \ get link to next word
   REPEAT
   CURSORX @ IF  NEWLINE  THEN ;     \ ensure we're on a new line
: WORDS   CONTEXT @  WORDLIST-WORDS ;
: ALL-WORDS   GET-ORDER 0 ?DO  WORDLIST-WORDS  LOOP ;


\ Environmental queries

: ENVIRONMENT?
   "CASE
      S" /COUNTED-STRING"    "OF  255                "ENDOF
      S" /HOLD"              "OF  256                "ENDOF
      S" /PAD"               "OF  256                "ENDOF
      S" ADDRESS-UNIT-BITS"  "OF  8                  "ENDOF
      S" BLOCK"              "OF  TRUE               "ENDOF
      S" BLOCK-EXT"          "OF  TRUE               "ENDOF
      S" CORE"               "OF  TRUE               "ENDOF
      S" CORE-EXT"           "OF  FALSE              "ENDOF
      S" DOUBLE"             "OF  FALSE              "ENDOF
      S" DOUBLE-EXT"         "OF  FALSE              "ENDOF
      S" EXCEPTION"          "OF  TRUE               "ENDOF
      S" EXCEPTION-EXT"      "OF  TRUE               "ENDOF
      S" FACILITY"           "OF  FALSE              "ENDOF
      S" FACILITY-EXT"       "OF  FALSE              "ENDOF
      S" FILE"               "OF  TRUE               "ENDOF
      S" FILE-EXT"           "OF  TRUE               "ENDOF
      S" FLOORED"            "OF  TRUE               "ENDOF
      S" MAX-CHAR"           "OF  255                "ENDOF
      S" MAX-D"              "OF  -1 1 RSHIFT S>D    "ENDOF
      S" MAX-N"              "OF  -1 1 RSHIFT        "ENDOF
      S" MAX-U"              "OF  -1                 "ENDOF
      S" MAX-UD"             "OF  -1 0               "ENDOF
      S" RETURN-STACK-CELLS" "OF  RETURN-STACK-CELLS "ENDOF
      S" SEARCH-ORDER"       "OF  TRUE               "ENDOF
      S" SEARCH-ORDER-EXT"   "OF  TRUE               "ENDOF
      S" STACK-CELLS"        "OF  STACK-CELLS        "ENDOF
      S" STRING"             "OF  TRUE               "ENDOF
      S" STRING-EXT"         "OF  TRUE               "ENDOF
      S" TOOLS"              "OF  FALSE              "ENDOF
      S" TOOLS-EXT"          "OF  FALSE              "ENDOF
      S" WORDLISTS"          "OF  8                  "ENDOF
      2DROP FALSE EXIT
   "ENDCASE
   TRUE ;


\ Exceptions #3

: (THROW)
   ?DUP IF                           \ if flag is true
      HANDLER @ ?DUP IF              \ and there's a frame to pop
         RP!                         \ set return stack to frame
         R>RESTORE-INPUT             \ restore input source
         R> HANDLER !                \ set pointer to next frame
         R> SWAP >R                  \ keep exception number
         SP!                         \ restore data stack
         R>                          \ restore exception number
      ELSE                           \ if no frame,
         ERROR-PREFIX                \ print any message
         DUP HANDLE-ERROR CR
         HALT                        \ and halt
      THEN
   THEN ;


INCLUDE" os.fs"   \ include OS access words
INCLUDE" save.fs"

: SAVE-IMAGE   ( c-addr u -- )
   'FORTH -ROT  ALIGN HERE 'FORTH - -ROT  SAVE-OBJECT ;


\ Command-line argument interface
\ (Design copied from GForth)

VARIABLE ARGC

: INITIALIZE-ARGS   TOTAL-ARGS ARGC ! ;

: ARG   TOTAL-ARGS ARGC @ -  +  ABSOLUTE-ARG ;
: SHIFT-ARGS   ARGC @ 1-  0 MAX  ARGC ! ;
: NEXT-ARG   0 ARG  SHIFT-ARGS ;


\ Initialisation and version number

: VERSION   S" @VERSION@" ;
INCLUDE" platform.fs"

: HELP
   ." Usage: "  "PROGRAM-NAME REL@ COUNT TYPE  ."  [OPTION...] [FILENAME...]" CR
   CR
   ." Run @PACKAGE_NAME@." CR
   CR
   ." --interact       enter interactive loop after evaluating" CR
   ."                  command-line arguments" CR
   ." --evaluate TEXT  evaluate the given text" CR
   ." --help           display this help message and exit" CR
   ." --version        display version information and exit" CR
   ." FILE             evaluate FILE" CR
   CR
   ." Report bugs to @PACKAGE_BUGREPORT@." CR ;

: BANNER
   ." @PACKAGE_NAME@ v" VERSION TYPE ."  (platform: " "PLATFORM TYPE ." )"
   CR ." (c) Reuben Thomas 1991-2021" CR ;

FALSE VALUE INTERACT?
: DO-START-OPTIONS
   ARGC @ IF
      HERE "PROGRAM-NAME REL!        \ update "PROGRAM-NAME
      NEXT-ARG ",                    \ save new name
   THEN
   ARGC @ IF
      BEGIN  NEXT-ARG OVER WHILE
         OVER C@  [CHAR] - =  IF     \ process option
            "CASE
               S" --help"     "OF  HELP BYE           "ENDOF
               S" --version"  "OF  BANNER BYE         "ENDOF
               S" --evaluate" "OF  NEXT-ARG EVALUATE  "ENDOF
               S" --interact" "OF  TRUE TO INTERACT?  "ENDOF
               HERE 'THROWN !  ",  -512 THROW
            "ENDCASE
         ELSE                        \ or interpret file
            \ FIXME: install CATCH handler, and if INTERACT? is true, even
            \ if case of error, respect it
            INCLUDED
         THEN
      REPEAT
      2DROP                          \ drop 0 0 from NEXT-ARG
      INTERACT? INVERT IF  BYE  THEN
   ELSE
      BANNER
   THEN
   (QUIT) ;

INCLUDE" parse-command-line.fs"

: START   ( limit here -- )
   ROOTDP !                          \ initialize dictionary pointer
   DUP TO LIMIT                      \ set LIMIT
   [ ' (THROW) ] RELATIVE-LITERAL 'THROW!
                                     \ set 'THROW
   0 HANDLER !                       \ reset HANDLER
   0 FILE-BUFFER# !                  \ reset FILE-BUFFER#
   DUP /BLOCK-BUFFER -               \ reserve block buffer,
   #FILE-BUFFERS /FILE-BUFFER * -    \ file buffers,
   DUP TO FIRST-FILE
   256 5 * -                         \ and TIB, PAD, TOKEN, SCRATCH and S"B
   'BUFFERS !                        \ set 'BUFFERS
   'BUFFERS @  TUCK -  ERASE         \ erase buffers
   ROOT                              \ use ROOT dictionary
   ONLY FORTH DEFINITIONS            \ minimal word list
   DECIMAL                           \ numbers treated as base 10
   PARSE-COMMAND-LINE
   INITIALIZE-ARGS
   INITIALIZE-TERMINAL
   DO-START-OPTIONS ;                \ process command-line args
